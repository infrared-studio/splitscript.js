const axios = require('axios');
const auth = require('../auth.js');
function isString(obj) {
	return typeof obj === 'string' || obj instanceof String;
}
/**
 * An ISO8601 formatted timestamp string
 * @typedef {string} ISO8601
 */
/**
 * A unique ID in twitters snowflake format
 * @typedef {string} Snowflake
 */
/**
 * Represents a message sent in a channel within Discord.
 * @typedef  {object} 		MessageObject
 * @property {Snowflake} 	id 				id of the message
 * @property {Snowflake} 	channel_id		id of the channel the message was sent in
 * @property {UserObject} 	author 			the author of this message
 * @property {string} 		content 			contents of the message
 * @property {ISO8601} 		timestamp			when this message was sent
 * @property {ISO8601=} 		edited_timestamp 	when this message was edited
 * @property {boolean} 		tts 				whether this was a TTS message
 * @property {boolean} 		mention_everyone 	whether this message mentions everyone
 * @property {UserObject[]} 	mentions			users specifically mentioned in the message
 * @property {Snowflake[]} 	mention_roles		roles specifically mentioned in this message
 * @property {ChannelMentionObject[]=} mention_channels channels specifically mentioned in this message
 * @property {AttachmentObject[]} attachments 	any attached files
 * @property {EmbedObject[]} 	embeds			any embedded content
 * @property {ReactionObject[]=} reactions		reactions to the message
 * @property {number | string=} nonce			used for validating a message was sent
 * @property {boolean} 		pinned			whether this message is pinned
 * @property {Snowflake=}	webhook_id		if the message is generated by a webhook, this is the webhook's id
 * @property {number}		type				type of message
 * @property {MessageActivityObject=} activity	sent with Rich Presence-related chat embeds
 * @property {ApplicationObject=} application	sent with Rich Presence-related chat embeds
 * @property {Snowflake=}	application_id			if the message is an Interaction or application-owned webhook, this is the id of the application
 * @property {MessageReferenceObject=} message_reference data showing the source of a crosspost, channel follow add, pin, or reply message
 * @property {number=}		flags				message flags combined as a bitfield
 * @property {MessageObject=} referenced_message		the message associated with the message_reference
 * @property {MessageInteractionObject} interaction	sent if the message is a response to an Interaction
 * @property {ChannelObject=}	thread			the thread that was started from this message, includes thread member object
 * @property {MessageComponent[]=} components	sent if the message contains components like buttons, action rows, or other interactive components
 * @property {StickerItem[]=} sticker_items		sent if the message contains stickers
 * @property {Sticker[]=}	stickers			Deprecated | the stickers sent with the message
 * @property {number=}		position			A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with total_message_sent on parent thread
 */
/**
 * An object representing a reaction
 * @typedef	{object}		ReactionObject
 * @property	{number}		count			integer - times this emoji has been used to react
 * @property	{boolean}		me				whether the current user reacted using this emoji
 * @property	{EmojiObject}	emoji			emoji information
 */
/**
 * An object representing an emoji
 * @typedef	{object}		EmojiObject
 * @property	{?Snowflake}	id				emoji id
 * @property	{?string}		name				emoji name - can only be null in reaction objects
 * @property	{object[]}	[roles]			roles allowed to use this emoji
 * @property	{UserObject}	[user]			user that created this emoji
 * @property	{boolean}		[require_colons]	whether this emoji must be wrapped in colons
 * @property	{boolean}		[managed]			whether this emoji is managed
 * @property	{boolean}		[animated]		whether this emoji is animated
 * @property	{boolean}		[available]		whether this emoji can be used
 */
/**
 * An object representing embedded content
 * @typedef	{object}		EmbedObject
 * @property	{string}		[title]			title of embed
 * @property	{string}		[type]			type of embed
 * @property	{string}		[description]		description of embed
 * @property	{string}		[url]			url of embed
 * @property	{ISO8601}		[timestamp]		timestamp of embed content
 * @property	{number}		[color]			color code of the embed
 * @property	{EmbedFooterObject} [footer] 		footer information
 * @property	{EmbedMediaObject} 	[image]		image information
 * @property 	{EmbedMediaObject} 	[thumbnail]	thumbnail information
 * @property	{EmbedMediaObject} 	[video]		video information
 * @property	{EmbedProviderObject} [provider]	provider information
 * @property	{EmbedAuthorObject} [author]		author information
 * @property	{EmbedFieldObject[]} [fields]		fields information
 */
/**
 * field information for embed
 * @typedef	{object}		EmbedFieldObject
 * @property	{string}		name				name of the field
 * @property	{string}		value			value of the field
 * @property	{boolean}		[inline]			whether or not this field should display inline
 */
/**
 * author information for embed
 * @typedef	{object}		EmbedAuthorObject
 * @property	{string}		name				name of author
 * @property	{string}		[url]			url of author
 * @property	{string}		[icon_url]		url of author icon (http(s) or attachments)
 * @property	{string}		[proxy_icon_url]	a proxied url of author icon
 */
/**
 * provider information for embed
 * @typedef 	{object}		EmbedProviderObject
 * @property	{string}		[name]				name of provider
 * @property	{string}		[url]				url of provider
 */
/**
 * Media information for embed
 * @typedef	{object}		EmbedMediaObject
 * @property	{string}		url				source url of media
 * @property	{string}		[proxy_url]		a proxied url of the image
 * @property	{number}		[height]			integer height of media
 * @property	{number}		[width]			integer width of image
 */

/**
 * Footer information for embed
 * @typedef 	{object}		EmbedFooterObject
 * @property	{string}		text				footer text
 * @property	{string}		[icon_url]		url of footer icon (http(s) or attachment url)
 * @property	{string}		[proxy_icon_url]	a proxied url of footer icon
 */
/**
 * An object representing a discord user
 * @typedef	{object}		UserObject
 * @property	{Snowflake}	id			The user's ID
 * @property	{string}		username		The user's username, not unique across the platform
 * @property	{string}		discriminator	The user's 4-digit discord-tag
 * @property	{string}		avatar		The user's avatar hash
 * @property	{boolean=}	bot			Whether the user is a bot
 * @property	{boolean=}	system		Whether the user is an Official Discord System user
 * @property	{boolean=}	mfa_enabled	Whether the user has two factor enabled on their account
 * @property	{string=}		banner		The user's banner hash
 * @property	{number=}		accent_color	The user's banner color encoded as an integer representation of hexadecimal color code
 * @property	{string=}		locale		The user's chosen language option
 * @property	{boolean=}	verified		Whether the email on this account has been verified
 * @property	{string=}		email		The users email
 * @property	{number=}		flags		The flags on a user's account
 * @property	{number=}		premium_type	The type of Nitro subscription on a user's account
 * @property	{number=}		public_flags	The public flags on a user's account
 */
/**
 * @typedef 	{object}		AttachmentObject
 * @property	{Snowflake}	id			attachment id
 * @property	{string}		filename		name of file attached
 * @property	{string}		[description]	description for the file (max 1024 characters)
 * @property	{string}		[content_type] the attachment's media type
 * @property	{number}		size			size of file in bytes
 * @property	{string}		url	source url of file
 * @property	{string}		proxy_url		a proxied url of file
 * @property	{number}		[height]		height of file (if image)
 * @property	{number}		[width]		width of file (if image)
 * @property	{boolean}		[ephemeral]	whether this attachment is ephemeral
 */
/**
 * @typedef 	{object}		MessageActivityObject
 * @property 	{number}		type 		type of message activity
 * @property	{string=}		party_id		party_id from a Rich Presence event
 */
/**
 * data showing the source of a crosspost, channel follow add, pin, or reply message
 * @typedef	{object}		MessageReferenceObject
 * @property	{Snowflake=}	message_id	id of the originating message
 * @property	{Snowflake=}	channel_id	id of the originating message's channel
 * @property	{Snowflake=}	guild_id		id of the originating message's guild
 * @property	{boolean=}	fail_if_not_exists when sending, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true
 */
/**
 * @typedef	{object}		ChannelMentionObject
 * @property	{Snowflake}	id			id of the channel
 * @property	{Snowflake}	guild_id		id of the guild containing the channel
 * @property	{number}		type			type of channel
 * @property	{string}		name			name of the channel
 */
/**
 * @typedef	{object}		MessageInteractionObject
 * @property	{Snowflake}	id			ID of the interaction
 * @property	{number}		type			Type of interaction
 * @property	{string}		name			Name of the application command, including subcommands and subcommand groups
 * @property	{UserObject}	user			User who invoked the interaction
 * @property	{MemberObject=} member		Member who invoked the interaction in the guild
 */
module.exports = {
	/**
	 * Send a message
	 * @param {MessageObject} message The message object to send
	 * @param {Snowflake} channel_id
	 * @returns {MessageObject} Message Object
	 */
	create: async function (message, channel_id) {
		try {
			if (isString(channel_id)) {
				const res = await axios.post(
					`https://discord.com/api/v10/channels/${channel_id}/messages`,
					message,
					{
						headers: {
							Authorization: `Bot ${auth.get('_token')}`,
							'Content-Type': 'application/json'
						}
					}
				);
				return res.data;
			} else {
				if (!message?.channel_id && !channel_id) {
					throw new TypeError('Property channel_id not set');
				}
				const res = await axios.post(
					`https://discord.com/api/v10/channels/${
						message.channel_id ?? channel_id
					}/messages`,
					message.message,
					{
						headers: {
							Authorization: `Bot ${auth.get('_token')}`,
							'Content-Type': 'application/json'
						}
					}
				);
				return res.data;
			}
		} catch (e) {
			throw new Error(JSON.stringify(e.response.data, null, 2));
		}
	},
	/**
	 * Update a message
	 * @param {MessageObject} newMessage
	 * @param {Snowflake} channel_id
	 * @param {Snowflake} message_id
	 * @returns {MessageObject} MessageObject
	 */
	edit: async function (newMessage, channel_id, message_id) {
		try {
			if (isString(newMessage)) {
				const res = await axios.patch(
					`https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}`,
					newMessage,
					{
						headers: {
							Authorization: `Bot ${auth.get('_token')}`,
							'Content-Type': 'application/json'
						}
					}
				);
				return res.data;
			} else {
				if (!newMessage?.channel_id && !channel_id) {
					throw new TypeError('Property channel_id not set');
				}
				if (!newMessage?.message_id && !message_id) {
					throw new TypeError('Property message_id not set');
				}
				const res = await axios.patch(
					`https://discord.com/api/v10/channels/${
						content?.channel_id ?? channel_id
					}/messages/${content?.message_id ?? message_id}`,
					newMessage.newMessage,
					{
						headers: {
							Authorization: `Bot ${auth.get('_token')}`,
							'Content-Type': 'application/json'
						}
					}
				);
				return res.data;
			}
		} catch (e) {
			throw new Error(JSON.stringify(e.response.data, null, 2));
		}
	},
	/**
	 * Delete a message
	 * @param {string} message_id
	 * @param {string} channel_id
	 * @returns {null} null
	 */
	delete: async function (message_id, channel_id) {
		try {
			if (!message_id) {
				throw new ReferenceError('Property message_id is not set');
			}
			if (!channel_id) {
				throw new ReferenceError('Property channel_id is not set');
			}
			let result = await axios.delete(
				`https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}`,
				{
					headers: {
						Authorization: `Bot ${auth.get('_token')}`,
						'Content-Type': 'application/json'
					}
				}
			);
			return result.data;
		} catch (e) {
			throw new Error(JSON.stringify(e.response.data, null, 2));
		}
	},
	/**
	 *
	 * @param {String} channel_id
	 * @param {string[]} messages
	 * @returns {Null} null
	 */
	bulkDelete: async function (channel_id, messages) {
		try {
			if (!channel_id) {
				throw new ReferenceError('Property channel_id is not set');
			}
			if (!messages) {
				throw new ReferenceError('Property messages is not set');
			}
			let result = await axios.post(
				`https://discord.com/api/v10/channels/${channel_id}/messages/bulk-delete`,
				{
					messages: messages
				},
				{
					headers: {
						Authorization: `Bot ${auth.get('_token')}`,
						'Content-Type': 'application/json'
					}
				}
			);
			return result.data;
		} catch (e) {
			throw new Error(JSON.stringify(e.response.data, null, 2));
		}
	},
	/**
	 *
	 * @param {Snowflake} message_id The ID of the message to get
	 * @param {Snowflake} channel_id The ID of the channel that the message is in
	 * @return {MessageObject} Message Object
	 */
	get: async function (message_id, channel_id) {
		if (!message_id) {
			throw new ReferenceError('Property message_id not set');
		}
		if (!channel_id) {
			throw new ReferenceError('Property channel_id not set');
		}

		try {
			let result = axios.get(
				`https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}`,
				{
					headers: {
						Authorization: `Bot ${auth.get('_token')}`,
						'Content-Type': 'application/json'
					}
				}
			);
			return result.data;
		} catch (e) {
			throw new Error(JSON.stringify(e.response.data, null, 2));
		}
	},
	/**
	 * Lists a channel messages
	 * @param {Snowflake} channel_id The channel id to look in
	 * @param {object} options Optional paramaters for filtering retrieved messages
	 * @param {Snowflake=} options.around Get messages around this message ID
	 * @param {Snowflake=} options.before Get messages before this message ID
	 * @param {Snowflake=} options.after Get messages after this message ID
	 * @param {number=} options.limit Max number of messages to return (1-100)
	 * @returns {MessageArray}
	 */
	list: async function (channel_id, options) {
		try {
			if (!channel_id) {
				throw new ReferenceError('Property channel_id is not set');
			}
			let result = await axios.get(
				`https://discord.com/api/v10/channels/${channel_id}/messages`,
				{
					data: new URLSearchParams(options),
					headers: {
						Authorization: `Bot ${auth.get('_token')}`,
						'Content-Type': 'application/json'
					}
				}
			);
			return result.data;
		} catch (e) {
			throw new Error(JSON.stringify(e.response.data, null, 2));
		}
	},
	reactions: {
		get: {
			all: async function (message_id, channel_id, emoji, options) {
				async function req(channel_id, message_id, emoji, options) {
					try {
						let result = await axios.get(
							`https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}/reactions/${encodeURIComponent(
								emoji
							)}` +
								(options
									? '?' +
									  new URLSearchParams(options).toString()
									: ''),
							{
								headers: {
									Authorization: `Bot ${auth.get('_token')}`,
									'Content-Type':
										'application/x-www-form-urlencoded'
								}
							}
						);
						return result.data;
					} catch (e) {
						throw new Error(
							JSON.stringify(e.response.data, null, 2)
						);
					}
				}
				if (isString(message_id)) {
					if (!message_id)
						throw new ReferenceError('Property message_id not set');
					if (!channel_id)
						throw new ReferenceError('Property channel_id not set');
					if (!emoji)
						throw new ReferenceError('Property emoji not set');
					let result = await req(
						channel_id,
						message_id,
						emoji,
						options
					);
					return result;
				} else {
					let {
						message_id: message__id,
						channel_id,
						emoji,
						options
					} = message_id;
					let result = await req(
						channel_id,
						message__id,
						emoji,
						options
					);
					return result;
				}
			}
		},
		create: async function (message_id, channel_id, emoji) {
			async function req(message_id, channel_id, emoji) {
				try {
					await axios.put(
						`https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}/reactions/${encodeURIComponent(
							emoji
						)}/@me`,
						{},
						{
							headers: {
								Authorization: `Bot ${auth.get('_token')}`,
								Accept: 'application/json'
							}
						}
					);
				} catch (e) {
					throw new Error(JSON.stringify(e.response.data, null, 2));
				}
			}
			if (!isString(message_id)) {
				let { message_id: message__id, channel_id, emoji } = message_id;
				console.log(message__id);
				console.log(message_id);
				req(message__id, channel_id, emoji);
				return;
			}
			req(message_id, channel_id, emoji);
		},
		delete: {
			own: async function (message_id, channel_id, emoji) {
				async function req(message_id, channel_id, emoji) {
					const URL = `https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}/reactions/${encodeURIComponent(
						emoji
					)}/@me`;
					try {
						await axios.delete(URL, {
							headers: {
								Authorization: `Bot ${auth.get('_token')}`,
								Accept: 'application/json'
							}
						});
					} catch (e) {
						console.log(e);
						throw e?.response?.data
							? new Error(
									JSON.stringify(e.response.data, null, 2)
							  )
							: e;
					}
				}
				if (isString(message_id)) {
					req(message_id, channel_id, emoji);
				} else {
					const {
						message_id: message__id,
						channel_id,
						emoji
					} = message_id;
					req(message__id, channel_id, emoji);
				}
			},
			user: async function (message_id, channel_id, emoji, user_id) {
				async function req(message_id, channel_id, emoji, user_id) {
					const URL = `https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}/reactions/${encodeURIComponent(
						emoji
					)}/${user_id}`;
					try {
						await axios.delete(URL, {
							headers: {
								Authorization: `Bot ${auth.get('_token')}`,
								Accept: 'application/json'
							}
						});
					} catch (e) {
						console.log(e);
						throw e?.response?.data
							? new Error(
									JSON.stringify(e.response.data, null, 2)
							  )
							: e;
					}
				}
				if (isString(message_id)) {
					req(message_id, channel_id, emoji, user_id);
				} else {
					const {
						message_id: message__id,
						channel_id,
						emoji,
						user_id
					} = message_id;
					req(message__id, channel_id, emoji, user_id);
				}
			},
			all: async function (message_id, channel_id, emoji) {
				async function req(message_id, channel_id, emoji) {
					let URL = `https://discord.com/api/v10/channels/${channel_id}/messages/${message_id}/reactions`;
					if (emoji) {
						URL += `/${encodeURIComponent(emoji)}`;
					}
					try {
						await axios.delete(URL, {
							headers: {
								Authorization: `Bot ${auth.get('_token')}`,
								Accept: 'application/json'
							}
						});
					} catch (e) {
						throw e?.response?.data
							? new Error(
									JSON.stringify(e.response.data, null, 2)
							  )
							: e;
					}
				}
				if (isString(message_id)) {
					req(message_id, channel_id, emoji);
				} else {
					let {
						message_id: message__id,
						channel_id,
						emoji
					} = message_id;
					req(message__id, channel_id, emoji);
				}
			}
		}
	}
};
